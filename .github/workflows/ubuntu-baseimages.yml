# Workflow name
name: 'Check Ubuntu Repos and Rebuild Base Images'

# Triggers for the workflow
on:
  # Runs on a schedule (at 1 and 31 minutes past the hour)
  schedule:
    - cron: '01,31 * * * *'
  # Allows manual triggering of the workflow
  workflow_dispatch:

# Defines the jobs to be run
jobs:
  # Job to check for updates and build images
  check-and-build:
    # Runner environment
    runs-on: ubuntu-latest
    # Permissions for the job
    permissions:
      contents: write
      packages: write
      security-events: write
    # Strategy for running the job
    strategy:
      # Don't cancel other jobs if one fails
      fail-fast: false
      # Matrix of OS versions to run the job against
      matrix:
        include:
          - os_version: "24.04"
            os_name: "noble"
          - os_version: "22.04"
            os_name: "jammy"
          - os_version: "20.04"
            os_name: "focal"
          - os_version: "18.04"
            os_name: "bionic"
          - os_version: "16.04"
            os_name: "xenial"
          - os_version: "14.04"
            os_name: "trusty"

    # Steps to be executed in the job
    steps:
      # Checks out the repository code
      - name: 'Check out the repo'
        uses: actions/checkout@v4

      # Sets up Docker Buildx for building images
      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3

      # Logs in to GitHub Container Registry
      - name: 'Log in to GitHub Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      # Gets the current date for tagging
      - name: Get current date
        id: get_date
        run: echo "date=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT

      # Convert repository owner to lowercase
      - name: 'Convert repository owner to lowercase'
        id: lowercase_owner
        run: echo "owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      # Builds the Docker image but does not push it
      - name: 'Build Docker image'
        id: build-image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.ubuntu
          push: false
          load: true
          build-args: |
            UBUNTU_VERSION=${{ matrix.os_version }}
          tags: |
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_version }}:latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_version }}:${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_version }}-latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_version }}-${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_name }}-latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_name }}-${{ steps.get_date.outputs.date }}
          cache-from: type=gha,scope=${{ github.workflow }}-${{ matrix.os_version }}
          cache-to: type=gha,mode=max,scope=${{ github.workflow }}-${{ matrix.os_version }}

      # Caches the package list hash to speed up subsequent runs
      - name: 'Cache package list hash for Ubuntu ${{ matrix.os_version }}'
        uses: actions/cache@v4
        id: cache-pkg-state
        with:
          path: package-state-${{ matrix.os_version }}.hash
          key: ubuntu-pkg-state-${{ matrix.os_version }}

      # Generates the current package list hash
      - name: 'Generate package list hash for Ubuntu ${{ matrix.os_version }}'
        id: generate_hash
        run: |
          echo "Generating package list hash for ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:latest..."
          CURRENT_HASH=$(docker run --rm ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:latest dpkg-query -W -f='${Package}\\t${Version}\\n' | sort | sha256sum | cut -d' ' -f1)
          echo "Current package hash: $CURRENT_HASH"
          echo "new_hash=$CURRENT_HASH" >> $GITHUB_OUTPUT

      # Compares the new hash with the old one to detect changes
      - name: 'Compare hashes for Ubuntu ${{ matrix.os_version }}'
        id: check_changes
        run: |
          OLD_HASH=$(cat package-state-${{ matrix.os_version }}.hash 2>/dev/null || echo "no-previous-hash")
          NEW_HASH="${{ steps.generate_hash.outputs.new_hash }}"
          if [ "$OLD_HASH" == "$NEW_HASH" ]; then
            echo "âœ… No package changes detected for Ubuntu ${{ matrix.os_version }}."
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "ðŸš¨ Package changes detected for Ubuntu ${{ matrix.os_version }}! Triggering rebuild."
            echo "changed=true" >> $GITHUB_OUTPUT
            echo $NEW_HASH > package-state-${{ matrix.os_version }}.hash
          fi
      
      # Installs Grype and clones templates for vulnerability scanning
      - name: 'Install Grype and clone templates'
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          git clone --depth 1 https://github.com/anchore/grype.git
          
      # Scans the image with Grype and generates various vulnerability reports
      - name: 'Scan image with Grype and generate all reports'
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          IMAGE_TAG="ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:latest"
        
          # Human-readable summary for the logs (doesn't save a file)
          echo "--- Generating Grype Table Report (for logs) ---"
          grype --scope all-layers $IMAGE_TAG -o table

          # JSON report (machine-readable, most detailed)
          echo "--- Generating Grype JSON Report ---"
          grype --scope all-layers $IMAGE_TAG -o json > grype-report-${{ matrix.os_name }}.json

          # SARIF report for security dashboards (e.g., GitHub Security tab)
          echo "--- Generating Grype SARIF Report ---"
          grype --scope all-layers $IMAGE_TAG -o sarif > grype-report-${{ matrix.os_name }}.sarif

          # CycloneDX XML report (SBOM format)
          echo "--- Generating Grype CycloneDX XML Report ---"
          grype --scope all-layers $IMAGE_TAG -o cyclonedx > grype-report-${{ matrix.os_name }}.cyclonedx.xml

          # CycloneDX JSON report (SBOM format)
          echo "--- Generating Grype CycloneDX JSON Report ---"
          grype --scope all-layers $IMAGE_TAG -o cyclonedx-json > grype-report-${{ matrix.os_name }}.cyclonedx.json

          # Custom CSV template report
          echo "--- Generating Grype Custom CSV Report ---"
          grype --scope all-layers $IMAGE_TAG -o template -t grype/templates/csv.tmpl > grype-report-${{ matrix.os_name }}.csv

          # Custom HTML template report
          echo "--- Generating Grype Custom HTML Report ---"
          grype --scope all-layers $IMAGE_TAG -o template -t grype/templates/html.tmpl > grype-report-${{ matrix.os_name }}.html

      # Uploads the generated vulnerability reports as artifacts
      - name: 'Upload vulnerability reports'
        if: steps.check_changes.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: vuln-reports-${{ matrix.os_name }}
          path: |
            grype-report-${{ matrix.os_name }}.json
            grype-report-${{ matrix.os_name }}.sarif
            grype-report-${{ matrix.os_name }}.cyclonedx.xml
            grype-report-${{ matrix.os_name }}.cyclonedx.json
            grype-report-${{ matrix.os_name }}.csv
            grype-report-${{ matrix.os_name }}.html

      # Pushes the Docker image to the registry
      - name: 'Push Docker image'
        if: ${{ steps.check_changes.outputs.changed == 'true' && success() }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.ubuntu
          push: true
          build-args: |
            UBUNTU_VERSION=${{ matrix.os_version }}
          # The tag remains dynamic as before
          tags: |
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_name }}:${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_version }}:latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu-${{ matrix.os_version }}:${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_version }}-latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_version }}-${{ steps.get_date.outputs.date }}
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_name }}-latest
            ghcr.io/${{ steps.lowercase_owner.outputs.owner }}/ubuntu:${{ matrix.os_name }}-${{ steps.get_date.outputs.date }}
          cache-from: type=gha,scope=${{ github.workflow }}-${{ matrix.os_version }}
          cache-to: type=gha,mode=max,scope=${{ github.workflow }}-${{ matrix.os_version }}

      # Determines the type of the repository owner (User or Organization)
      - name: Get repository owner type
        id: owner_type
        if: ${{ steps.check_changes.outputs.changed == 'true' && success() }}
        run: |
          OWNER_TYPE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/users/${{ github.repository_owner }}" | jq -r .type)
          echo "type=${OWNER_TYPE}" >> $GITHUB_OUTPUT

      # Makes the container packages public after they are pushed
      - name: Make packages public
        if: ${{ steps.check_changes.outputs.changed == 'true' && success() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LOWERCASE_OWNER="${{ steps.lowercase_owner.outputs.owner }}"
          PACKAGE_NAMES="ubuntu ubuntu-${{ matrix.os_name }} ubuntu-${{ matrix.os_version }}"

          if [ "${{ steps.owner_type.outputs.type }}" == "Organization" ]; then
            API_BASE_URL="https://api.github.com/orgs/$LOWERCASE_OWNER/packages/container"
          else
            API_BASE_URL="https://api.github.com/user/packages/container"
          fi

          for PACKAGE_NAME in $PACKAGE_NAMES; do
            echo "Making $PACKAGE_NAME public..."
            curl -s -f -X PATCH \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "$API_BASE_URL/$PACKAGE_NAME" \
              -d '{"visibility":"public"}'
          done
            
  # Job to update the README file
  update-readme:
    # Depends on the completion of the check-and-build job
    needs: check-and-build
    # Runner environment
    runs-on: ubuntu-latest
    # Permissions for the job
    permissions:
      contents: write
    # Steps to be executed in the job
    steps:
      # Checks out the repository code
      - name: 'Check out the repo'
        uses: actions/checkout@v4

      # Downloads the vulnerability reports from the previous job
      - name: 'Download vulnerability reports'
        uses: actions/download-artifact@v4
        with:
          path: ./reports-tmp
        continue-on-error: true

      - name: 'Check for downloaded reports'
        id: check_reports
        run: |
          if [ -d "reports-tmp" ] && [ -n "$(ls -A reports-tmp)" ]; then
            echo "reports_downloaded=true"
            echo "reports_downloaded=true" >> $GITHUB_OUTPUT
          else
            echo "reports_downloaded=false"
            echo "reports_downloaded=false" >> $GITHUB_OUTPUT
          fi

      # Moves the reports into the repository for processing
      - name: 'Move reports into repo'
        if: steps.check_reports.outputs.reports_downloaded == 'true'
        run: |
          mkdir -p vuln-reports
          for report_dir in reports-tmp/vuln-reports-*; do
            OS_NAME=$(basename "$report_dir" | sed 's/vuln-reports-//')
            TARGET_DIR="vuln-reports-$OS_NAME"
            rm -rf "$TARGET_DIR"
            mv "$report_dir" "$TARGET_DIR"
          done
          rm -rf reports-tmp

      # Updates the README with vulnerability badges based on the scan results
      - name: 'Update README with vuln badges'
        if: steps.check_reports.outputs.reports_downloaded == 'true'
        run: |
          for report_dir in vuln-reports-*; do
              OS_NAME=$(echo "$report_dir" | sed 's/vuln-reports-//')
              report_path="$report_dir/grype-report-$OS_NAME.csv"

              if [ ! -f "$report_path" ]; then
                echo "Vulnerability report not found for $OS_NAME. Skipping."
                continue
              fi

              CRITICAL=$(grep -c "Critical" "$report_path" || true)
              HIGH=$(grep -c "High" "$report_path" || true)
              MEDIUM=$(grep -c "Medium" "$report_path" || true)
              LOW=$(grep -c "Low" "$report_path" || true)

              REPORT_URL="https://htmlpreview.github.io/?https://github.com/${{ github.repository }}/blob/main/$report_dir/grype-report-$OS_NAME.html"
              VULN_BADGES_LINE="[![Critical Vulns](https://img.shields.io/badge/Critical-$CRITICAL-red.svg)]($REPORT_URL) [![High Vulns](https://img.shields.io/badge/High-$HIGH-orange.svg)]($REPORT_URL) [![Medium Vulns](https://img.shields.io/badge/Medium-$MEDIUM-yellow.svg)]($REPORT_URL) [![Low Vulns](https://img.shields.io/badge/Low-$LOW-blue.svg)]($REPORT_URL)"

              case "$OS_NAME" in
                  noble)
                      sed -i "/### Ubuntu 24.04 Noble/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
                  jammy)
                      sed -i "/### Ubuntu 22.04 Jammy/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
                  focal)
                      sed -i "/### Ubuntu 20.04 Focal/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
                  bionic)
                      sed -i "/### Ubuntu 18.04 Bionic/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
                  xenial)
                      sed -i "/### Ubuntu 16.04 Xenial/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
                  trusty)
                      sed -i "/### Ubuntu 14.04 Trusty/!b;n;c$VULN_BADGES_LINE" README.md
                      ;;
              esac
          done

      # Commits and pushes the changes to the repository
      - name: 'Commit and push changes'
        if: steps.check_reports.outputs.reports_downloaded == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update vulnerability badges and reports"
          file_pattern: "README.md vuln-reports-*"
